import 'dart:async';
import 'package:booking_petcare/Controller/Appointment/UpcomingAppointmentController.dart';
import 'package:booking_petcare/Controller/Pets/PetsController.dart';
import 'package:booking_petcare/Controller/Services/ServiceController.dart';
import 'package:booking_petcare/Global/Constant.dart';
import 'package:booking_petcare/Model/Appointment/AppointmentModel.dart';
import 'package:booking_petcare/Model/Prescription/PrescriptionModel.dart';
import 'package:booking_petcare/Services/APICaller.dart';
import 'package:booking_petcare/Services/PushNotification.dart';
import 'package:booking_petcare/Utils/Utils.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart';

// ‚úÖ B∆Ø·ªöC 1: ƒê·ªäNH NGHƒ®A CLASS TimeSlotDisplayInfo
class TimeSlotDisplayInfo {
  final TimeOfDay time;
  final bool isBooked;
  final bool isPast;

  TimeSlotDisplayInfo({
    required this.time,
    this.isBooked = false,
    this.isPast = false,
  });

  bool get isSelectable => !isBooked && !isPast;

  @override
  String toString() {
    return 'TimeSlot(time: ${time.hour}:${time.minute}, booked: $isBooked, past: $isPast, selectable: $isSelectable)';
  }
}

class AppointmentController extends GetxController {
  // --- ID Trung t√¢m m·∫∑c ƒë·ªãnh ---
  final String defaultCenterId = "1";

  var appointments = <AppointmentModel>[].obs;
  var isLoadingAppointments = true.obs;
  List<AppointmentModel> allAppointments = [];

  RxBool isExpanded = false.obs;

  //ƒê·∫∑t l·ªãch
  var selectedPet = ''.obs;
  // var selectedCenter = ''.obs;
  var selectedServiceIds = <int>[].obs;
  var selectedDate = DateTime.now().obs;
  // var selectedTime = TimeOfDay.now().obs;
  var selectedTime = Rx<TimeOfDay?>(null);

  // Th√¥ng tin ng∆∞·ªùi d√πng
  var userName = ''.obs;
  var phoneNumber = ''.obs;
  var address = ''.obs;

  var selectedPrescription = Rxn<Prescription>(); // Rxn cho ph√©p gi√° tr·ªã null
  var isLoadingPrescription = false.obs;
  var prescriptionError = Rxn<String>();

  // --- Th√™m c√°c bi·∫øn cho logic ch·ªçn gi·ªù ---
  // var availableTimeSlots = <TimeOfDay>[].obs;
  var displayableTimeSlots = <TimeSlotDisplayInfo>[].obs;
  var bookedStartTimesForSelectedDate = <TimeOfDay>[].obs;

  final TimeOfDay openingTime = TimeOfDay(hour: 8, minute: 0); // 8 AM
  final TimeOfDay closingTime = TimeOfDay(hour: 17, minute: 0); // 5 PM
  final int slotIncrementInMinutes = 60; // M·ªói slot c√°ch nhau 60 ph√∫t

  @override
  void onInit() {
    super.onInit();
    fetchAllAppointments();
    loadUserInfo();

    // ‚úÖ TH√äM: Logic x·ª≠ l√Ω khi ng√†y thay ƒë·ªïi v√† t·∫£i slot l·∫ßn ƒë·∫ßu
    ever(selectedDate, (_) {
      selectedTime.value = null; // Reset gi·ªù ƒë√£ ch·ªçn khi ƒë·ªïi ng√†y
      fetchAndGenerateAvailableSlots();
    });
    fetchAndGenerateAvailableSlots(); // T·∫£i slot l·∫ßn ƒë·∫ßu cho ng√†y hi·ªán t·∫°i
  }

  //l·∫•y th√¥ng tin ng∆∞·ªùi d√πng
  void loadUserInfo() async {
    userName.value =
        await Utils.getStringValueWithKey(Constant.TEN_NGUOIDUNG) ?? '';
    phoneNumber.value = await Utils.getStringValueWithKey(Constant.SDT) ?? '';
    address.value = await Utils.getStringValueWithKey(Constant.DIACHI) ?? '';
  }

  // ‚úÖ TH√äM: H√†m t·∫£i v√† t·∫°o c√°c slot gi·ªù tr·ªëng
  Future<void> fetchAndGenerateAvailableSlots() async {
    displayableTimeSlots.clear(); // X√≥a danh s√°ch c≈©
    bookedStartTimesForSelectedDate.clear();

    print(
        'üì° G·ªçi API getlichtrungtamtheongay.php cho ng√†y: ${DateFormat('yyyy-MM-dd').format(selectedDate.value)}, centerId: $defaultCenterId');
    try {
      var response = await APICaller.getInstance().get(
        "User/Lichhen/getlichtrungtamtheongay.php",
        queryParams: {
          "idtrungtam": defaultCenterId,
          "ngayhen": DateFormat('yyyy-MM-dd').format(selectedDate.value),
        },
      );

      if (response != null && response is List) {
        List<TimeOfDay> fetchedTimes = [];
        for (var item in response) {
          if (item is Map && item.containsKey('thoigianhen')) {
            String timeStr = item['thoigianhen'];
            try {
              TimeOfDay parsedTime;
              if (RegExp(r'^[0-2]?[0-9]:[0-5][0-9]$').hasMatch(timeStr)) {
                final parts = timeStr.split(':');
                parsedTime = TimeOfDay(
                    hour: int.parse(parts[0]), minute: int.parse(parts[1]));
              } else if (timeStr.contains('AM') || timeStr.contains('PM')) {
                DateTime tempDate =
                    DateFormat("h:mm a", "en_US").parse(timeStr);
                parsedTime = TimeOfDay.fromDateTime(tempDate);
              } else {
                final parts = timeStr.split(':');
                parsedTime = TimeOfDay(
                    hour: int.parse(parts[0]), minute: int.parse(parts[1]));
              }
              fetchedTimes.add(parsedTime);
            } catch (e) {
              print('‚ùå L·ªói parse th·ªùi gian t·ª´ API: "$timeStr" - $e');
            }
          }
        }
        bookedStartTimesForSelectedDate.assignAll(fetchedTimes);
        print(
            'üóìÔ∏è C√°c gi·ªù ƒë√£ ƒë·∫∑t cho ng√†y ${selectedDate.value.toIso8601String().substring(0, 10)}: $bookedStartTimesForSelectedDate');
      } else {
        print(
            '‚ÑπÔ∏è Kh√¥ng c√≥ gi·ªù n√†o ƒë∆∞·ª£c ƒë·∫∑t ho·∫∑c ph·∫£n h·ªìi API kh√¥ng h·ª£p l·ªá cho getlichtrungtamtheongay.php. Response: $response');
      }
    } catch (e) {
      print('‚ùå L·ªói khi t·∫£i c√°c gi·ªù ƒë√£ ƒë·∫∑t: $e');
    }

    List<TimeSlotDisplayInfo> newSlots = []; // Danh s√°ch t·∫°m th·ªùi
    DateTime now = DateTime.now();
    DateTime date = selectedDate.value;
    TimeOfDay currentTimeSlot = openingTime;

    while ((currentTimeSlot.hour < closingTime.hour) ||
        (currentTimeSlot.hour == closingTime.hour &&
            currentTimeSlot.minute < closingTime.minute)) {
      bool isBooked = bookedStartTimesForSelectedDate.any((bookedTime) =>
          bookedTime.hour == currentTimeSlot.hour &&
          bookedTime.minute == currentTimeSlot.minute);

      bool isPastSlotForToday = false;
      if (date.year == now.year &&
          date.month == now.month &&
          date.day == now.day) {
        DateTime currentSlotDateTime = DateTime(date.year, date.month, date.day,
            currentTimeSlot.hour, currentTimeSlot.minute);
        if (currentSlotDateTime
            .isBefore(now.subtract(const Duration(seconds: 1)))) {
          isPastSlotForToday = true;
        }
      }

      newSlots.add(TimeSlotDisplayInfo(
        time: currentTimeSlot,
        isBooked: isBooked,
        isPast: isPastSlotForToday,
      ));

      int currentTotalMinutes =
          currentTimeSlot.hour * 60 + currentTimeSlot.minute;
      int nextTotalMinutes = currentTotalMinutes + slotIncrementInMinutes;

      if (nextTotalMinutes >= (closingTime.hour * 60 + closingTime.minute)) {
        break;
      }
      if (nextTotalMinutes < 24 * 60) {
        currentTimeSlot = TimeOfDay(
            hour: nextTotalMinutes ~/ 60, minute: nextTotalMinutes % 60);
      } else {
        break;
      }
    }
    displayableTimeSlots.assignAll(newSlots); // C·∫≠p nh·∫≠t danh s√°ch ch√≠nh
    print('üÜï Danh s√°ch slot hi·ªÉn th·ªã: $displayableTimeSlots');

    // Ki·ªÉm tra v√† reset selectedTime n·∫øu n√≥ kh√¥ng c√≤n h·ª£p l·ªá
    if (selectedTime.value != null) {
      final currentSelectedSlotInfo = displayableTimeSlots.firstWhereOrNull(
          (info) =>
              info.time.hour == selectedTime.value!.hour &&
              info.time.minute == selectedTime.value!.minute);
      if (currentSelectedSlotInfo == null ||
          !currentSelectedSlotInfo.isSelectable) {
        selectedTime.value = null;
      }
    }

    if (displayableTimeSlots.where((s) => s.isSelectable).isEmpty) {
      print(
          'üö´ Kh√¥ng c√≥ gi·ªù tr·ªëng n√†o (c√≥ th·ªÉ ch·ªçn) cho ng√†y ${DateFormat('dd/MM/yyyy').format(selectedDate.value)}');
    }
  }

  // l·∫•y t√™n th√∫ c∆∞ng
  String getSelectedPetName() {
    final petController = Get.find<PetsController>();
    final pet = petController.pets
        .firstWhereOrNull((p) => p.idthucung.toString() == selectedPet.value);
    return pet?.tenthucung ?? 'Ch∆∞a ch·ªçn';
  }

  // l·∫•y danh s√°ch t√™n d·ªãch v·ª•
  String getSelectedServiceNames() {
    final serviceController = Get.find<ServiceController>();

    if (selectedServiceIds.isEmpty) return 'Ch∆∞a ch·ªçn';

    List<String> names = selectedServiceIds
        .map((id) {
          final service = serviceController.filteredServices
              .firstWhereOrNull((s) => s.id == id);
          return service?.name ?? '';
        })
        .where((name) => name.isNotEmpty)
        .toList();

    return names.isEmpty ? 'Ch∆∞a ch·ªçn' : names.join(', ');
  }

  // x√°c nh·∫≠n ƒë·∫∑t l·ªãch
  Future<bool> submitBooking() async {
    try {
      var idUser = await Utils.getStringValueWithKey(Constant.ID_NGUOIDUNG);

      if (idUser == null ||
          selectedPet.value.isEmpty ||
          selectedServiceIds.isEmpty) {
        Utils.showSnackBar(
            title: 'L·ªói', message: 'Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin.');
        return false; // <- tr·∫£ v·ªÅ false khi thi·∫øu th√¥ng tin
      }
      // ‚úÖ Parse idUserStr sang int m·ªôt l·∫ßn ·ªü ƒë√¢y
      final int idUserInt;
      try {
        idUserInt = int.parse(idUser);
      } catch (e) {
        print('‚ùå L·ªói parse ID ng∆∞·ªùi d√πng: $e');
        Utils.showSnackBar(
            title: 'L·ªói', message: 'ID ng∆∞·ªùi d√πng kh√¥ng h·ª£p l·ªá.');
        return false;
      }

      // Ki·ªÉm tra l·∫°i xem gi·ªù ƒë√£ ch·ªçn c√≥ th·ª±c s·ª± h·ª£p l·ªá kh√¥ng
      final selectedSlotInfo = displayableTimeSlots.firstWhereOrNull((info) =>
          info.time.hour == selectedTime.value!.hour &&
          info.time.minute == selectedTime.value!.minute);

      if (selectedSlotInfo == null || !selectedSlotInfo.isSelectable) {
        Utils.showSnackBar(
            title: 'L·ªói',
            message:
                'Gi·ªù b·∫°n ch·ªçn kh√¥ng c√≤n tr·ªëng ho·∫∑c kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªçn l·∫°i.',
            duration: Duration(seconds: 4));
        fetchAndGenerateAvailableSlots(); // T·∫£i l·∫°i slot ƒë·ªÉ ng∆∞·ªùi d√πng th·∫•y s·ª± thay ƒë·ªïi (n·∫øu c√≥)
        return false;
      }

      var bookingData = {
        "idnguoidung": idUserInt,
        "idthucung": int.parse(selectedPet.value),
        "idtrungtam":
            int.parse(defaultCenterId), // ‚úÖ S·ª¨A: S·ª≠ d·ª•ng defaultCenterId
        "ngayhen": DateFormat('yyyy-MM-dd').format(selectedDate.value),
        "thoigianhen":
            selectedTime.value!.format(Get.context!), // ƒê√£ ki·ªÉm tra null ·ªü tr√™n
        "dichvu": selectedServiceIds.toList(),
      };
      // var bookingData = {
      //   "idnguoidung": idUserInt,
      //   "idthucung": int.parse(selectedPet.value),
      //   "idtrungtam": selectedCenter.value.isNotEmpty
      //       ? int.parse(selectedCenter.value)
      //       : 1,
      //   "ngayhen": DateFormat('yyyy-MM-dd').format(selectedDate.value),
      //   "thoigianhen": selectedTime.value.format(Get.context!),
      //   "dichvu": selectedServiceIds.toList(),
      // };

      print('üì§ D·ªØ li·ªáu g·ª≠i ƒëi: $bookingData');

      var response = await APICaller.getInstance().post(
        "User/Lichhen/themlichhen.php",
        bookingData,
      );

      if (response != null && response["success"] == true) {
        // Utils.showSnackBar(
        //     title: 'Th√†nh c√¥ng', message: 'ƒê·∫∑t l·ªãch th√†nh c√¥ng!');
        fetchAllAppointments();
        Get.find<UpcomingAppointmentController>().fetchUpcomingAppointments();

        // G·ªåI scheduleReminders ƒë·ªÉ th√¥ng b√°o ƒë·ªãnh k·ª≥
        try {
          final DateTime appointmentDateTime = DateTime(
            selectedDate.value.year,
            selectedDate.value.month,
            selectedDate.value.day,
            selectedTime.value!.hour,
            selectedTime.value!.minute,
          );

          String petName = getSelectedPetName();
          String serviceNames = getSelectedServiceNames();

          String formattedTime =
              DateFormat('HH:mm').format(appointmentDateTime);
          String formattedDate =
              DateFormat('dd/MM/yyyy').format(appointmentDateTime);

          String reminderTitle = 'L·ªãch h·∫πn s·∫Øp t·ªõi cho $petName';
          String reminderBody =
              'B·∫°n c√≥ l·ªãch h·∫πn v√†o l√∫c $formattedTime ng√†y $formattedDate. D·ªãch v·ª•: $serviceNames.';

          if (petName == 'Ch∆∞a ch·ªçn') {
            reminderTitle = 'L·ªãch h·∫πn s·∫Øp t·ªõi c·ªßa b·∫°n';
          }

          print(
              'DEBUG (AppointmentController): Chu·∫©n b·ªã g·ªçi scheduleReminders v·ªõi:');

          print('idnguoidung: $idUserInt');
          print('appointmentDateTime: $appointmentDateTime');
          print('Ti√™u ƒë·ªÅ: $reminderTitle');
          print('N·ªôi dung: $reminderBody');

          await PushNotifications.scheduleReminders(
            idUserInt,
            appointmentDateTime,
            tieude: reminderTitle,
            noidung: reminderBody,
          );
          print(
              'DEBUG (AppointmentController): ƒê√£ g·ªçi xong PushNotifications.scheduleReminders.');
        } catch (e) {
          print('‚ùå L·ªói khi g·ªçi scheduleReminders: $e');
        }
        return true;
      } else {
        Utils.showSnackBar(
          title: 'L·ªói',
          message: response != null
              ? (response["message"] ?? "L·ªói kh√¥ng x√°c ƒë·ªãnh")
              : "ƒê·∫∑t l·ªãch th·∫•t b·∫°i.",
        );
        return false;
      }
    } catch (e) {
      print('‚ùå L·ªói khi ƒë·∫∑t l·ªãch: $e');
      Utils.showSnackBar(title: 'L·ªói', message: 'ƒê√£ x·∫£y ra l·ªói khi ƒë·∫∑t l·ªãch.');
      return false;
    }
  }

  // reset t√πy ch·ªçn ƒë·∫∑t l·ªãch
  void resetBookingForm() {
    selectedPet.value = '';
    selectedServiceIds.clear();
    selectedDate.value = DateTime.now();
    // selectedTime.value = TimeOfDay.now();
    selectedTime.value = null;
  }

  Future<void> fetchAllAppointments() async {
    try {
      isLoadingAppointments.value = true;
      print('üì° G·ªçi API getlichhenbynguoidung.php...');

      String? idNguoiDung =
          await Utils.getStringValueWithKey(Constant.ID_NGUOIDUNG);

      if (idNguoiDung == null) {
        throw Exception('‚ùó Kh√¥ng t√¨m th·∫•y ID ng∆∞·ªùi d√πng trong b·ªô nh·ªõ');
      }

      var response = await APICaller.getInstance()
          .get('User/Lichhen/getlichhenbynguoidung.php', queryParams: {
        "idnguoidung": idNguoiDung,
      });

      List<AppointmentModel> parsedAppointments = [];

      if (response is List) {
        parsedAppointments = response
            .map((e) {
              try {
                return AppointmentModel.fromJson(e);
              } catch (error) {
                print('‚ùå L·ªói khi parse JSON: $error v·ªõi d·ªØ li·ªáu: $e');
                return null;
              }
            })
            .whereType<AppointmentModel>()
            .toList();
      } else if (response is Map && response.containsKey('data')) {
        parsedAppointments = (response['data'] as List)
            .map((e) {
              try {
                return AppointmentModel.fromJson(e);
              } catch (error) {
                print('‚ùå L·ªói parse JSON: $error v·ªõi d·ªØ li·ªáu: $e');
                return null;
              }
            })
            .whereType<AppointmentModel>()
            .toList();
      } else {
        throw Exception('‚ùå Ph·∫£n h·ªìi API kh√¥ng h·ª£p l·ªá');
      }

      allAppointments = parsedAppointments;
      appointments.assignAll(parsedAppointments);
    } catch (e) {
      print('‚ùå L·ªói khi l·∫•y l·ªãch h·∫πn: $e');
      Utils.showSnackBar(
          title: 'L·ªói', message: 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch l·ªãch h·∫πn');
    } finally {
      isLoadingAppointments.value = false;
    }
  }

  //h·ªßy l·ªãch h·∫πn
  Future<void> cancelAppointment(int idlichhen, String reason) async {
    try {
      // Th√™m ti·ªÅn t·ªë "[User]: " v√†o tr∆∞·ªõc l√Ω do h·ªßy
      String reasonWithSender = "[User]: $reason"; // <--- THAY ƒê·ªîI ·ªû ƒê√ÇY

      var response = await APICaller.getInstance().post(
        "User/Lichhen/huylichhen.php",
        {
          "idlichhen": idlichhen,
          "reason": reasonWithSender, // S·ª≠ d·ª•ng l√Ω do ƒë√£ c√≥ ti·ªÅn t·ªë
        },
      );

      if (response != null && response["success"] == true) {
        await fetchAllAppointments(); // üõ† Load l·∫°i t·ª´ API
        // Gi·∫£ s·ª≠ b·∫°n c√≥ UpcomingAppointmentController v√† mu·ªën c·∫≠p nh·∫≠t n√≥
        if (Get.isRegistered<UpcomingAppointmentController>()) {
          Get.find<UpcomingAppointmentController>().fetchUpcomingAppointments();
        }
        Get.snackbar('Th√†nh c√¥ng', 'H·ªßy l·ªãch h·∫πn th√†nh c√¥ng!',
            backgroundColor: Colors.green, colorText: Colors.white);
      } else {
        Utils.showSnackBar(
          title: 'L·ªói',
          message: response != null
              ? (response["message"] ?? "H·ªßy l·ªãch th·∫•t b·∫°i.")
              : "H·ªßy l·ªãch th·∫•t b·∫°i.",
        );
      }
    } catch (e) {
      print('‚ùå L·ªói khi h·ªßy l·ªãch: $e');
      Get.snackbar('L·ªói', 'Kh√¥ng th·ªÉ h·ªßy l·ªãch h·∫πn!',
          backgroundColor: Colors.red, colorText: Colors.white);
    }
  }

  Future<void> fetchPrescriptionDetails(int idlichhen) async {
    const String userFriendlyNoPrescriptionMessage =
        "L·ªãch h·∫πn n√†y kh√¥ng c√≥ ƒë∆°n thu·ªëc.";
    const String apiOriginalNoPrescriptionMessage =
        "Kh√¥ng t√¨m th·∫•y ƒë∆°n thu·ªëc cho l·ªãch h·∫πn n√†y";

    try {
      isLoadingPrescription.value = true;
      prescriptionError.value = null;
      selectedPrescription.value = null;

      debugPrint(
          'üì° ƒêang g·ªçi API: User/Donthuoc/getdonthuocbylichhen.php cho idlichhen: $idlichhen');

      var responseFromApiCaller = await APICaller.getInstance().get(
        'User/Donthuoc/getdonthuocbylichhen.php',
        queryParams: {"idlichhen": idlichhen.toString()},
      );

      if (responseFromApiCaller == null) {
        // THEO Y√äU C·∫¶U: di·ªÖn gi·∫£i null t·ª´ APICaller l√† "Kh√¥ng c√≥ ƒë∆°n thu·ªëc"
        // C·∫¢NH B√ÅO: ƒêi·ªÅu n√†y c√≥ th·ªÉ che gi·∫•u l·ªói m·∫°ng/server th·ª±c s·ª±.
        prescriptionError.value = userFriendlyNoPrescriptionMessage;
        debugPrint(
            '‚ÑπÔ∏è APICaller tr·∫£ v·ªÅ null, ƒë∆∞·ª£c di·ªÖn gi·∫£i l√† "$userFriendlyNoPrescriptionMessage" cho idlichhen: $idlichhen.');
      } else if (responseFromApiCaller is Map &&
          responseFromApiCaller.containsKey('error') &&
          responseFromApiCaller['error'] is Map) {
        final errorData = responseFromApiCaller['error'];
        final int errorCode = errorData['code'] ?? -1;
        final String apiMessage =
            errorData['message'] ?? 'L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ API.';

        if (errorCode == 0) {
          if (responseFromApiCaller['data'] != null &&
              responseFromApiCaller['data'] is Map<String, dynamic> &&
              (responseFromApiCaller['data'] as Map).isNotEmpty) {
            try {
              selectedPrescription.value = Prescription.fromJson(
                  responseFromApiCaller['data'] as Map<String, dynamic>);
              debugPrint(
                  'üíä ƒê∆°n thu·ªëc t·∫£i th√†nh c√¥ng (response ƒë·∫ßy ƒë·ªß, error.code=0) cho idlichhen: $idlichhen');
            } catch (e, stackTrace) {
              debugPrint(
                  '‚ùå L·ªói parse Prescription.fromJson (response ƒë·∫ßy ƒë·ªß, error.code=0): $e\n$stackTrace\nData: ${responseFromApiCaller['data']}');
              prescriptionError.value =
                  'L·ªói x·ª≠ l√Ω d·ªØ li·ªáu ƒë∆°n thu·ªëc nh·∫≠n ƒë∆∞·ª£c (m√£ 0).';
            }
          } else {
            prescriptionError.value =
                'API b√°o th√†nh c√¥ng (m√£ 0) nh∆∞ng kh√¥ng c√≥ d·ªØ li·ªáu chi ti·∫øt.';
            debugPrint(
                '‚ÑπÔ∏è API b√°o error.code == 0 (response ƒë·∫ßy ƒë·ªß) nh∆∞ng data kh√¥ng h·ª£p l·ªá/tr·ªëng cho idlichhen: $idlichhen.');
          }
        } else {
          // API b√°o l·ªói (errorCode != 0)
          if (apiMessage == apiOriginalNoPrescriptionMessage) {
            prescriptionError.value = userFriendlyNoPrescriptionMessage;
          } else {
            prescriptionError.value = apiMessage;
          }
          debugPrint(
              '‚ùå L·ªói t·ª´ API (code: $errorCode): "$apiMessage". Full response: $responseFromApiCaller');
        }
      } else if (responseFromApiCaller is Map<String, dynamic>) {
        if (responseFromApiCaller.isNotEmpty) {
          try {
            selectedPrescription.value =
                Prescription.fromJson(responseFromApiCaller);
            debugPrint(
                'üíä ƒê∆°n thu·ªëc t·∫£i th√†nh c√¥ng (data tr·ª±c ti·∫øp) cho idlichhen: $idlichhen');
          } catch (e, stackTrace) {
            debugPrint(
                '‚ùå L·ªói parse Prescription.fromJson (data tr·ª±c ti·∫øp): $e\n$stackTrace\nData: $responseFromApiCaller');
            prescriptionError.value = 'L·ªói x·ª≠ l√Ω d·ªØ li·ªáu ƒë∆°n thu·ªëc nh·∫≠n ƒë∆∞·ª£c.';
          }
        } else {
          prescriptionError.value = userFriendlyNoPrescriptionMessage;
          debugPrint(
              '‚ÑπÔ∏è D·ªØ li·ªáu ƒë∆°n thu·ªëc tr·ªëng ƒë∆∞·ª£c tr·∫£ v·ªÅ (data tr·ª±c ti·∫øp) cho idlichhen: $idlichhen, di·ªÖn gi·∫£i l√† "$userFriendlyNoPrescriptionMessage".');
        }
      } else {
        prescriptionError.value =
            'Ph·∫£n h·ªìi t·ª´ m√°y ch·ªß c√≥ ƒë·ªãnh d·∫°ng kh√¥ng mong ƒë·ª£i.';
        debugPrint(
            '‚ùå Ph·∫£n h·ªìi API ... c√≥ ki·ªÉu kh√¥ng mong ƒë·ª£i: ${responseFromApiCaller.runtimeType}. Response: $responseFromApiCaller');
      }
    } catch (e, stackTrace) {
      debugPrint(
          '‚ùå L·ªói nghi√™m tr·ªçng x·∫£y ra trong fetchPrescriptionDetails: $e\n$stackTrace');
      prescriptionError.value =
          'ƒê√£ x·∫£y ra s·ª± c·ªë kh√¥ng mong mu·ªën. Vui l√≤ng th·ª≠ l·∫°i.';
    } finally {
      isLoadingPrescription.value = false;
      if (prescriptionError.value != null && Get.isSnackbarOpen != true) {
        // Bi·∫øn userFriendlyNoPrescriptionMessage gi·ªù ƒë√£ c√≥ th·ªÉ truy c·∫≠p ·ªü ƒë√¢y
        bool isInformationalOnly =
            prescriptionError.value == userFriendlyNoPrescriptionMessage;

        Utils.showSnackBar(
          title: isInformationalOnly ? 'Th√¥ng b√°o' : 'L·ªói',
          message: prescriptionError.value!,
          isError: !isInformationalOnly,
          backgroundColor:
              isInformationalOnly ? Colors.blueGrey.shade700 : null,
          icon: isInformationalOnly
              ? const Icon(Icons.info_outline_rounded, color: Colors.white)
              : null,
        );
      }
    }
  }
}
